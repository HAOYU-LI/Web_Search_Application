{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.PriorityQueue = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) {\n      s(r[o]);\n    }\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      var AbstractPriorityQueue,\n          ArrayStrategy,\n          BHeapStrategy,\n          BinaryHeapStrategy,\n          PriorityQueue,\n          extend = function extend(child, parent) {\n        for (var key in parent) {\n          if (hasProp.call(parent, key)) child[key] = parent[key];\n        }\n\n        function ctor() {\n          this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n        child.__super__ = parent.prototype;\n        return child;\n      },\n          hasProp = {}.hasOwnProperty;\n\n      AbstractPriorityQueue = _dereq_('./PriorityQueue/AbstractPriorityQueue');\n      ArrayStrategy = _dereq_('./PriorityQueue/ArrayStrategy');\n      BinaryHeapStrategy = _dereq_('./PriorityQueue/BinaryHeapStrategy');\n      BHeapStrategy = _dereq_('./PriorityQueue/BHeapStrategy');\n\n      PriorityQueue = function (superClass) {\n        extend(PriorityQueue, superClass);\n\n        function PriorityQueue(options) {\n          options || (options = {});\n          options.strategy || (options.strategy = BinaryHeapStrategy);\n          options.comparator || (options.comparator = function (a, b) {\n            return (a || 0) - (b || 0);\n          });\n\n          PriorityQueue.__super__.constructor.call(this, options);\n        }\n\n        return PriorityQueue;\n      }(AbstractPriorityQueue);\n\n      PriorityQueue.ArrayStrategy = ArrayStrategy;\n      PriorityQueue.BinaryHeapStrategy = BinaryHeapStrategy;\n      PriorityQueue.BHeapStrategy = BHeapStrategy;\n      module.exports = PriorityQueue;\n    }, {\n      \"./PriorityQueue/AbstractPriorityQueue\": 2,\n      \"./PriorityQueue/ArrayStrategy\": 3,\n      \"./PriorityQueue/BHeapStrategy\": 4,\n      \"./PriorityQueue/BinaryHeapStrategy\": 5\n    }],\n    2: [function (_dereq_, module, exports) {\n      var AbstractPriorityQueue;\n\n      module.exports = AbstractPriorityQueue = function () {\n        function AbstractPriorityQueue(options) {\n          var ref;\n\n          if ((options != null ? options.strategy : void 0) == null) {\n            throw 'Must pass options.strategy, a strategy';\n          }\n\n          if ((options != null ? options.comparator : void 0) == null) {\n            throw 'Must pass options.comparator, a comparator';\n          }\n\n          this.priv = new options.strategy(options);\n          this.length = (options != null ? (ref = options.initialValues) != null ? ref.length : void 0 : void 0) || 0;\n        }\n\n        AbstractPriorityQueue.prototype.queue = function (value) {\n          this.length++;\n          this.priv.queue(value);\n          return void 0;\n        };\n\n        AbstractPriorityQueue.prototype.dequeue = function (value) {\n          if (!this.length) {\n            throw 'Empty queue';\n          }\n\n          this.length--;\n          return this.priv.dequeue();\n        };\n\n        AbstractPriorityQueue.prototype.peek = function (value) {\n          if (!this.length) {\n            throw 'Empty queue';\n          }\n\n          return this.priv.peek();\n        };\n\n        AbstractPriorityQueue.prototype.clear = function () {\n          this.length = 0;\n          return this.priv.clear();\n        };\n\n        return AbstractPriorityQueue;\n      }();\n    }, {}],\n    3: [function (_dereq_, module, exports) {\n      var ArrayStrategy, binarySearchForIndexReversed;\n\n      binarySearchForIndexReversed = function binarySearchForIndexReversed(array, value, comparator) {\n        var high, low, mid;\n        low = 0;\n        high = array.length;\n\n        while (low < high) {\n          mid = low + high >>> 1;\n\n          if (comparator(array[mid], value) >= 0) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n\n        return low;\n      };\n\n      module.exports = ArrayStrategy = function () {\n        function ArrayStrategy(options) {\n          var ref;\n          this.options = options;\n          this.comparator = this.options.comparator;\n          this.data = ((ref = this.options.initialValues) != null ? ref.slice(0) : void 0) || [];\n          this.data.sort(this.comparator).reverse();\n        }\n\n        ArrayStrategy.prototype.queue = function (value) {\n          var pos;\n          pos = binarySearchForIndexReversed(this.data, value, this.comparator);\n          this.data.splice(pos, 0, value);\n          return void 0;\n        };\n\n        ArrayStrategy.prototype.dequeue = function () {\n          return this.data.pop();\n        };\n\n        ArrayStrategy.prototype.peek = function () {\n          return this.data[this.data.length - 1];\n        };\n\n        ArrayStrategy.prototype.clear = function () {\n          this.data.length = 0;\n          return void 0;\n        };\n\n        return ArrayStrategy;\n      }();\n    }, {}],\n    4: [function (_dereq_, module, exports) {\n      var BHeapStrategy;\n\n      module.exports = BHeapStrategy = function () {\n        function BHeapStrategy(options) {\n          var arr, i, j, k, len, ref, ref1, shift, value;\n\n          this.comparator = (options != null ? options.comparator : void 0) || function (a, b) {\n            return a - b;\n          };\n\n          this.pageSize = (options != null ? options.pageSize : void 0) || 512;\n          this.length = 0;\n          shift = 0;\n\n          while (1 << shift < this.pageSize) {\n            shift += 1;\n          }\n\n          if (1 << shift !== this.pageSize) {\n            throw 'pageSize must be a power of two';\n          }\n\n          this._shift = shift;\n          this._emptyMemoryPageTemplate = arr = [];\n\n          for (i = j = 0, ref = this.pageSize; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            arr.push(null);\n          }\n\n          this._memory = [];\n          this._mask = this.pageSize - 1;\n\n          if (options.initialValues) {\n            ref1 = options.initialValues;\n\n            for (k = 0, len = ref1.length; k < len; k++) {\n              value = ref1[k];\n              this.queue(value);\n            }\n          }\n        }\n\n        BHeapStrategy.prototype.queue = function (value) {\n          this.length += 1;\n\n          this._write(this.length, value);\n\n          this._bubbleUp(this.length, value);\n\n          return void 0;\n        };\n\n        BHeapStrategy.prototype.dequeue = function () {\n          var ret, val;\n          ret = this._read(1);\n          val = this._read(this.length);\n          this.length -= 1;\n\n          if (this.length > 0) {\n            this._write(1, val);\n\n            this._bubbleDown(1, val);\n          }\n\n          return ret;\n        };\n\n        BHeapStrategy.prototype.peek = function () {\n          return this._read(1);\n        };\n\n        BHeapStrategy.prototype.clear = function () {\n          this.length = 0;\n          this._memory.length = 0;\n          return void 0;\n        };\n\n        BHeapStrategy.prototype._write = function (index, value) {\n          var page;\n          page = index >> this._shift;\n\n          while (page >= this._memory.length) {\n            this._memory.push(this._emptyMemoryPageTemplate.slice(0));\n          }\n\n          return this._memory[page][index & this._mask] = value;\n        };\n\n        BHeapStrategy.prototype._read = function (index) {\n          return this._memory[index >> this._shift][index & this._mask];\n        };\n\n        BHeapStrategy.prototype._bubbleUp = function (index, value) {\n          var compare, indexInPage, parentIndex, parentValue;\n          compare = this.comparator;\n\n          while (index > 1) {\n            indexInPage = index & this._mask;\n\n            if (index < this.pageSize || indexInPage > 3) {\n              parentIndex = index & ~this._mask | indexInPage >> 1;\n            } else if (indexInPage < 2) {\n              parentIndex = index - this.pageSize >> this._shift;\n              parentIndex += parentIndex & ~(this._mask >> 1);\n              parentIndex |= this.pageSize >> 1;\n            } else {\n              parentIndex = index - 2;\n            }\n\n            parentValue = this._read(parentIndex);\n\n            if (compare(parentValue, value) < 0) {\n              break;\n            }\n\n            this._write(parentIndex, value);\n\n            this._write(index, parentValue);\n\n            index = parentIndex;\n          }\n\n          return void 0;\n        };\n\n        BHeapStrategy.prototype._bubbleDown = function (index, value) {\n          var childIndex1, childIndex2, childValue1, childValue2, compare;\n          compare = this.comparator;\n\n          while (index < this.length) {\n            if (index > this._mask && !(index & this._mask - 1)) {\n              childIndex1 = childIndex2 = index + 2;\n            } else if (index & this.pageSize >> 1) {\n              childIndex1 = (index & ~this._mask) >> 1;\n              childIndex1 |= index & this._mask >> 1;\n              childIndex1 = childIndex1 + 1 << this._shift;\n              childIndex2 = childIndex1 + 1;\n            } else {\n              childIndex1 = index + (index & this._mask);\n              childIndex2 = childIndex1 + 1;\n            }\n\n            if (childIndex1 !== childIndex2 && childIndex2 <= this.length) {\n              childValue1 = this._read(childIndex1);\n              childValue2 = this._read(childIndex2);\n\n              if (compare(childValue1, value) < 0 && compare(childValue1, childValue2) <= 0) {\n                this._write(childIndex1, value);\n\n                this._write(index, childValue1);\n\n                index = childIndex1;\n              } else if (compare(childValue2, value) < 0) {\n                this._write(childIndex2, value);\n\n                this._write(index, childValue2);\n\n                index = childIndex2;\n              } else {\n                break;\n              }\n            } else if (childIndex1 <= this.length) {\n              childValue1 = this._read(childIndex1);\n\n              if (compare(childValue1, value) < 0) {\n                this._write(childIndex1, value);\n\n                this._write(index, childValue1);\n\n                index = childIndex1;\n              } else {\n                break;\n              }\n            } else {\n              break;\n            }\n          }\n\n          return void 0;\n        };\n\n        return BHeapStrategy;\n      }();\n    }, {}],\n    5: [function (_dereq_, module, exports) {\n      var BinaryHeapStrategy;\n\n      module.exports = BinaryHeapStrategy = function () {\n        function BinaryHeapStrategy(options) {\n          var ref;\n\n          this.comparator = (options != null ? options.comparator : void 0) || function (a, b) {\n            return a - b;\n          };\n\n          this.length = 0;\n          this.data = ((ref = options.initialValues) != null ? ref.slice(0) : void 0) || [];\n\n          this._heapify();\n        }\n\n        BinaryHeapStrategy.prototype._heapify = function () {\n          var i, j, ref;\n\n          if (this.data.length > 0) {\n            for (i = j = 1, ref = this.data.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n              this._bubbleUp(i);\n            }\n          }\n\n          return void 0;\n        };\n\n        BinaryHeapStrategy.prototype.queue = function (value) {\n          this.data.push(value);\n\n          this._bubbleUp(this.data.length - 1);\n\n          return void 0;\n        };\n\n        BinaryHeapStrategy.prototype.dequeue = function () {\n          var last, ret;\n          ret = this.data[0];\n          last = this.data.pop();\n\n          if (this.data.length > 0) {\n            this.data[0] = last;\n\n            this._bubbleDown(0);\n          }\n\n          return ret;\n        };\n\n        BinaryHeapStrategy.prototype.peek = function () {\n          return this.data[0];\n        };\n\n        BinaryHeapStrategy.prototype.clear = function () {\n          this.length = 0;\n          this.data.length = 0;\n          return void 0;\n        };\n\n        BinaryHeapStrategy.prototype._bubbleUp = function (pos) {\n          var parent, x;\n\n          while (pos > 0) {\n            parent = pos - 1 >>> 1;\n\n            if (this.comparator(this.data[pos], this.data[parent]) < 0) {\n              x = this.data[parent];\n              this.data[parent] = this.data[pos];\n              this.data[pos] = x;\n              pos = parent;\n            } else {\n              break;\n            }\n          }\n\n          return void 0;\n        };\n\n        BinaryHeapStrategy.prototype._bubbleDown = function (pos) {\n          var last, left, minIndex, right, x;\n          last = this.data.length - 1;\n\n          while (true) {\n            left = (pos << 1) + 1;\n            right = left + 1;\n            minIndex = pos;\n\n            if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {\n              minIndex = left;\n            }\n\n            if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {\n              minIndex = right;\n            }\n\n            if (minIndex !== pos) {\n              x = this.data[minIndex];\n              this.data[minIndex] = this.data[pos];\n              this.data[pos] = x;\n              pos = minIndex;\n            } else {\n              break;\n            }\n          }\n\n          return void 0;\n        };\n\n        return BinaryHeapStrategy;\n      }();\n    }, {}]\n  }, {}, [1])(1);\n});","map":null,"metadata":{},"sourceType":"script"}